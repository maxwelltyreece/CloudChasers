"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.accessiblityValueKeys = exports.accessibilityStateKeys = void 0;
exports.getAccessibilityCheckedState = getAccessibilityCheckedState;
exports.getAccessibilityLabel = getAccessibilityLabel;
exports.getAccessibilityLabelledBy = getAccessibilityLabelledBy;
exports.getAccessibilityRole = getAccessibilityRole;
exports.getAccessibilityState = getAccessibilityState;
exports.getAccessibilityValue = getAccessibilityValue;
exports.getAccessibilityViewIsModal = getAccessibilityViewIsModal;
exports.getAccessibleName = getAccessibleName;
exports.isAccessibilityElement = isAccessibilityElement;
exports.isElementBusy = isElementBusy;
exports.isElementCollapsed = isElementCollapsed;
exports.isElementExpanded = isElementExpanded;
exports.isElementSelected = isElementSelected;
exports.isHiddenFromAccessibility = isHiddenFromAccessibility;
exports.isInaccessible = void 0;
var _reactNative = require("react-native");
var _componentTree = require("./component-tree");
var _hostComponentNames = require("./host-component-names");
var _textContent = require("./text-content");
const accessibilityStateKeys = exports.accessibilityStateKeys = ['disabled', 'selected', 'checked', 'busy', 'expanded'];
const accessiblityValueKeys = exports.accessiblityValueKeys = ['min', 'max', 'now', 'text'];
function isHiddenFromAccessibility(element, {
  cache
} = {}) {
  if (element == null) {
    return true;
  }
  let current = element;
  while (current) {
    let isCurrentSubtreeInaccessible = cache?.get(current);
    if (isCurrentSubtreeInaccessible === undefined) {
      isCurrentSubtreeInaccessible = isSubtreeInaccessible(current);
      cache?.set(current, isCurrentSubtreeInaccessible);
    }
    if (isCurrentSubtreeInaccessible) {
      return true;
    }
    current = current.parent;
  }
  return false;
}

/** RTL-compatitibility alias for `isHiddenFromAccessibility` */
const isInaccessible = exports.isInaccessible = isHiddenFromAccessibility;
function isSubtreeInaccessible(element) {
  // Null props can happen for React.Fragments
  if (element.props == null) {
    return false;
  }

  // See: https://reactnative.dev/docs/accessibility#aria-hidden
  if (element.props['aria-hidden']) {
    return true;
  }

  // iOS: accessibilityElementsHidden
  // See: https://reactnative.dev/docs/accessibility#accessibilityelementshidden-ios
  if (element.props.accessibilityElementsHidden) {
    return true;
  }

  // Android: importantForAccessibility
  // See: https://reactnative.dev/docs/accessibility#importantforaccessibility-android
  if (element.props.importantForAccessibility === 'no-hide-descendants') {
    return true;
  }

  // Note that `opacity: 0` is not treated as inaccessible on iOS
  const flatStyle = _reactNative.StyleSheet.flatten(element.props.style) ?? {};
  if (flatStyle.display === 'none') return true;

  // iOS: accessibilityViewIsModal or aria-modal
  // See: https://reactnative.dev/docs/accessibility#accessibilityviewismodal-ios
  const hostSiblings = (0, _componentTree.getHostSiblings)(element);
  if (hostSiblings.some(sibling => getAccessibilityViewIsModal(sibling))) {
    return true;
  }
  return false;
}
function isAccessibilityElement(element) {
  if (element == null) {
    return false;
  }
  if (element.props.accessible !== undefined) {
    return element.props.accessible;
  }
  const hostComponentNames = (0, _hostComponentNames.getHostComponentNames)();
  return element?.type === hostComponentNames?.text || element?.type === hostComponentNames?.textInput || element?.type === hostComponentNames?.switch;
}

/**
 * Returns the accessibility role for given element. It will return explicit
 * role from either `role` or `accessibilityRole` props if set.
 *
 * If explicit role is not available, it would try to return default element
 * role:
 * - `text` for `Text` elements
 *
 * In all other cases this functions returns `none`.
 *
 * @param element
 * @returns
 */
function getAccessibilityRole(element) {
  const explicitRole = element.props.role ?? element.props.accessibilityRole;
  if (explicitRole) {
    return explicitRole;
  }
  if ((0, _hostComponentNames.isHostText)(element)) {
    return 'text';
  }
  return 'none';
}
function getAccessibilityViewIsModal(element) {
  return element.props['aria-modal'] ?? element.props.accessibilityViewIsModal;
}
function getAccessibilityLabel(element) {
  return element.props['aria-label'] ?? element.props.accessibilityLabel;
}
function getAccessibilityLabelledBy(element) {
  return element.props['aria-labelledby'] ?? element.props.accessibilityLabelledBy;
}
function getAccessibilityState(element) {
  const {
    accessibilityState,
    'aria-busy': ariaBusy,
    'aria-checked': ariaChecked,
    'aria-disabled': ariaDisabled,
    'aria-expanded': ariaExpanded,
    'aria-selected': ariaSelected
  } = element.props;
  const hasAnyAccessibilityStateProps = accessibilityState != null || ariaBusy != null || ariaChecked != null || ariaDisabled != null || ariaExpanded != null || ariaSelected != null;
  if (!hasAnyAccessibilityStateProps) {
    return undefined;
  }
  return {
    busy: ariaBusy ?? accessibilityState?.busy,
    checked: ariaChecked ?? accessibilityState?.checked,
    disabled: ariaDisabled ?? accessibilityState?.disabled,
    expanded: ariaExpanded ?? accessibilityState?.expanded,
    selected: ariaSelected ?? accessibilityState?.selected
  };
}
function getAccessibilityCheckedState(element) {
  const {
    accessibilityState,
    'aria-checked': ariaChecked
  } = element.props;
  return ariaChecked ?? accessibilityState?.checked;
}
function getAccessibilityValue(element) {
  const {
    accessibilityValue,
    'aria-valuemax': ariaValueMax,
    'aria-valuemin': ariaValueMin,
    'aria-valuenow': ariaValueNow,
    'aria-valuetext': ariaValueText
  } = element.props;
  const hasAnyAccessibilityValueProps = accessibilityValue != null || ariaValueMax != null || ariaValueMin != null || ariaValueNow != null || ariaValueText != null;
  if (!hasAnyAccessibilityValueProps) {
    return undefined;
  }
  return {
    max: ariaValueMax ?? accessibilityValue?.max,
    min: ariaValueMin ?? accessibilityValue?.min,
    now: ariaValueNow ?? accessibilityValue?.now,
    text: ariaValueText ?? accessibilityValue?.text
  };
}
function isElementBusy(element) {
  const {
    accessibilityState,
    'aria-busy': ariaBusy
  } = element.props;
  return ariaBusy ?? accessibilityState?.busy ?? false;
}
function isElementCollapsed(element) {
  const {
    accessibilityState,
    'aria-expanded': ariaExpanded
  } = element.props;
  return (ariaExpanded ?? accessibilityState?.expanded) === false;
}
function isElementExpanded(element) {
  const {
    accessibilityState,
    'aria-expanded': ariaExpanded
  } = element.props;
  return ariaExpanded ?? accessibilityState?.expanded ?? false;
}
function isElementSelected(element) {
  const {
    accessibilityState,
    'aria-selected': ariaSelected
  } = element.props;
  return ariaSelected ?? accessibilityState?.selected ?? false;
}
function getAccessibleName(element) {
  const label = getAccessibilityLabel(element);
  if (label) {
    return label;
  }
  const labelElementId = getAccessibilityLabelledBy(element);
  if (labelElementId) {
    const rootElement = (0, _componentTree.getUnsafeRootElement)(element);
    const labelElement = rootElement?.findByProps({
      nativeID: labelElementId
    });
    if (labelElement) {
      return (0, _textContent.getTextContent)(labelElement);
    }
  }
  return (0, _textContent.getTextContent)(element);
}
//# sourceMappingURL=accessiblity.js.map