"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.longPress = longPress;
exports.press = press;
var _componentTree = require("../../helpers/component-tree");
var _textInput = require("../../helpers/text-input");
var _pointerEvents = require("../../helpers/pointer-events");
var _hostComponentNames = require("../../helpers/host-component-names");
var _eventBuilder = require("../event-builder");
var _utils = require("../utils");
var _constants = require("./constants");
async function press(element) {
  await basePress(this.config, element, {
    type: 'press',
    duration: 0
  });
}
async function longPress(element, options) {
  await basePress(this.config, element, {
    type: 'longPress',
    duration: options?.duration ?? 500
  });
}
const basePress = async (config, element, options) => {
  if (isPressableText(element)) {
    await emitTextPressEvents(config, element, options);
    return;
  }
  if ((0, _hostComponentNames.isHostTextInput)(element) && (0, _textInput.isTextInputEditable)(element) && (0, _pointerEvents.isPointerEventEnabled)(element)) {
    await emitTextInputPressEvents(config, element, options);
    return;
  }
  if (isEnabledTouchResponder(element)) {
    await emitPressablePressEvents(config, element, options);
    return;
  }
  const hostParentElement = (0, _componentTree.getHostParent)(element);
  if (!hostParentElement) {
    return;
  }
  await basePress(config, hostParentElement, options);
};
const emitPressablePressEvents = async (config, element, options) => {
  (0, _utils.warnAboutRealTimersIfNeeded)();
  await (0, _utils.wait)(config);
  (0, _utils.dispatchEvent)(element, 'responderGrant', _eventBuilder.EventBuilder.Common.responderGrant());
  await (0, _utils.wait)(config, options.duration);
  (0, _utils.dispatchEvent)(element, 'responderRelease', _eventBuilder.EventBuilder.Common.responderRelease());

  // React Native will wait for minimal delay of DEFAULT_MIN_PRESS_DURATION
  // before emitting the `pressOut` event. We need to wait here, so that
  // `press()` function does not return before that.
  if (_constants.DEFAULT_MIN_PRESS_DURATION - options.duration > 0) {
    await (0, _utils.wait)(config, _constants.DEFAULT_MIN_PRESS_DURATION - options.duration);
  }
};
const isEnabledTouchResponder = element => {
  return (0, _pointerEvents.isPointerEventEnabled)(element) && element.props.onStartShouldSetResponder?.();
};
const isPressableText = element => {
  const hasPressEventHandler = Boolean(element.props.onPress || element.props.onLongPress || element.props.onPressIn || element.props.onPressOut);
  return (0, _hostComponentNames.isHostText)(element) && (0, _pointerEvents.isPointerEventEnabled)(element) && !element.props.disabled && hasPressEventHandler;
};

/**
 * Dispatches a press event sequence for Text.
 */
async function emitTextPressEvents(config, element, options) {
  await (0, _utils.wait)(config);
  (0, _utils.dispatchEvent)(element, 'pressIn', _eventBuilder.EventBuilder.Common.touch());

  // Emit either `press` or `longPress`.
  (0, _utils.dispatchEvent)(element, options.type, _eventBuilder.EventBuilder.Common.touch());
  await (0, _utils.wait)(config, options.duration);
  (0, _utils.dispatchEvent)(element, 'pressOut', _eventBuilder.EventBuilder.Common.touch());
}

/**
 * Dispatches a press event sequence for TextInput.
 */
async function emitTextInputPressEvents(config, element, options) {
  await (0, _utils.wait)(config);
  (0, _utils.dispatchEvent)(element, 'pressIn', _eventBuilder.EventBuilder.Common.touch());

  // Note: TextInput does not have `onPress`/`onLongPress` props.

  await (0, _utils.wait)(config, options.duration);
  (0, _utils.dispatchEvent)(element, 'pressOut', _eventBuilder.EventBuilder.Common.touch());
}
//# sourceMappingURL=press.js.map